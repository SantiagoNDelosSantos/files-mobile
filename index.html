<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drag and Drop con Botón</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <!-- Agregar estilos de Cropper.js -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css" rel="stylesheet">
    <style>
        body {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Montserrat';
            font-size: 0.9em;
            overflow: auto !important;
        }

        *:focus {
            outline: none;
            /* Esto quita el borde celeste que aparece cuando cualquier elemento está enfocado */
        }

        /*Contenedor para el formulario en general todos los inputs*/
        .contendorForm {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            padding: 2em;
            gap: 1em;
            border-radius: 3em;
        }

        .contenedorFileInput {
            width: 100%;
        }

        /* El area del dropzone y todo lo que este adentro */
        #dropzone {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            border: 1.5px dashed #ccc;
            padding: 1em 6em;
            padding-top: 2em;
            text-align: center;
            border-radius: 0.7em;
            width: auto;
            margin-top: 1em;
            cursor: pointer;
        }

        /* Hover para el area del dropzone, oscurece el fondo y cambia el boder de punteado a solid */
        #dropzone.hover {
            border: 1.5px solid #cacaca;
            background-color: #f0f0f0a2;
        }

        #divTabla {
            display: none;
        }

        #tablaPreview {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            width: 100%;
        }

        tr {
            display: flex;
            flex-direction: row;
        }

        td {
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-direction: row;
            border: 1.5px solid #ccc;
            padding: 0.5em;
            text-align: center;
            border-radius: 0.7em;
            height: 5%;
            margin-bottom: 1em;
        }

        tbody,
        tr,
        td {
            width: 100%;
        }

        .actions {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: row;
        }

        .svg {
            width: 1.5em;
            height: 1.5em;
            padding: 0.2em;
            margin-left: 0.3em;
            cursor: pointer;
        }

        .svg:hover {
            background-color: #e7e5e5;
            border-radius: 100%;
        }

        .svg2 {
            width: 1.5em;
            height: 1.5em;
            padding: 0.2em;
            margin-left: 0.3em;
        }

        #divCrop {
            display: none;
        }

        .shapes {
            border: 0.2em dashed black;
            cursor: pointer;
        }

        .shapes:hover {
            border: 0.2em dashed #009FF5;
        }

        .cropper-view-box {
            outline: 2px dashed #009FF5;
        }

        .cropper-dashed {
            border: #ff000000;
        }

        .cropper-line {
            background-color: #ff000000;
        }

        .cropper-point.point-se {
            bottom: 0px;
            right: 0px;
        }

        .cropper-point.point-e,
        .cropper-point.point-n,
        .cropper-point.point-w,
        .cropper-point.point-s,
        .cropper-point.point-nw,
        .cropper-point.point-ne,
        .cropper-point.point-sw {
            display: none;
        }

        .cropper-center:after,
        .cropper-center:before {
            background-color: #00a6ff;
            opacity: 1;
        }

        .cropper-point.point-se {
            background-color: #00a6ff;
            opacity: 1;
            height: 1rem;
            width: 1rem;
            margin-bottom: 1%;
            margin-right: 1%;
        }
    </style>

</head>

<body>

    <div class="contendorForm">

        <h2>Titulo</h2>
        <input type="text">

        <h2>Subir imagenes</h2>

        <div class="contenedorFileInput">

            <div id="divCrop"></div>

            <div id="divTabla">
                <table id="tablaPreview"></table>
            </div>

            <div id="dropzone" class="dropzone" draggable="true">

                <svg class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg"
                    width="40" height="40" fill="none" viewBox="0 0 24 24">
                    <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M15 17h3a3 3 0 0 0 0-6h-.025a5.56 5.56 0 0 0 .025-.5A5.5 5.5 0 0 0 7.207 9.021C7.137 9.017 7.071 9 7 9a4 4 0 1 0 0 8h2.167M12 19v-9m0 0-2 2m2-2 2 2" />
                </svg>

                <p id="parrafoDropZone">
                    Haz clic para seleccionar las imágenes.
                </p>

                <input type="file" id="fileInput" style="display: none;" multiple>

            </div>

        </div>

        <button id="uploadButton">Crear producto</button>

    </div>

    <!-- Agregar script de Cropper.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>

    <script>

        // Acá tendriamos el dropzone y el input file
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('fileInput');

        // Se agrega un event listener al área de soltar (dropzone) que se activa cuando un archivo se arrastra sobre él. Este event listener previene el comportamiento por defecto del navegador (e.preventDefault()) y añade la clase hover al dropzone.
        dropzone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropzone.classList.add('hover');
        });

        // Se agrega un event listener al área de soltar (dropzone) que se activa cuando un archivo se arrastra fuera de él. Este event listener remueve la clase hover del dropzone.
        dropzone.addEventListener('dragleave', () => {
            dropzone.classList.remove('hover');
        });

        // Se agrega un event listener al área de soltar (dropzone) que se activa cuando se hace clic sobre él. Este event listener simula un clic en el fileInput, permitiendo que los usuarios seleccionen archivos mediante el clic en el dropzone.
        dropzone.addEventListener('click', () => {
            fileInput.click();
        });



        // Tanto si se arrastra un archivo dentro del file como si se hace clic y se selecciona un archivo se ejecutan estas dos funciones a continuación:

        // Se agrega un event listener al área de soltar (dropzone) que se activa cuando se suelta un archivo sobre él. Este event listener previene el comportamiento por defecto del navegador (e.preventDefault()), remueve la clase hover del dropzone, y llama a la función handleFile() pasando el archivo soltado como argumento.
        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropzone.classList.remove('hover');
            const files = e.dataTransfer.files;
            handleFiles(files); // Llama a la función handleFiles() para manejar todos los archivos soltados
        });

        // Se agrega un event listener al fileInput que se activa cuando se selecciona un archivo. Este event listener llama a la función handleFiles() pasando todos los archivos seleccionados como argumento.
        fileInput.addEventListener('change', async () => {
            const files = fileInput.files;
            await handleFiles(files); // Llama a la función handleFiles() para manejar todos los archivos seleccionados
            fileInput.value = ""
        });


        // ACÁ SE VAN GUARDANDO LOS ARCHIVOS QUE SE VAN SUBIENDO.
        let allFiles = []

        // Capturamos el parrafo del dropzone:
        function actualizarParrafo(allFiles) {
            let parrafoDropZone = document.getElementById("parrafoDropZone");
            parrafoDropZone.innerText = `Puedes subir hasta 5 imágenes por publicación (${allFiles.length}/5).`;
        }

        // Acá campuramos el dom de la tabla.
        let table = document.getElementById("tablaPreview")
        let divTabla = document.getElementById("divTabla")

        let htmlPreview = "";
        // Acá tendriamos que configurar la función que deberia cargar la tabla con los archivos que se fueron seleccionando.
        function mostrarImagenesEnTabla() {
            if (allFiles.length > 0) {

                htmlPreview = ``
                allFiles.forEach((img, index) => {

                    // Suponiendo que 'img' es un objeto que contiene el Blob de la imagen
                    const objectURL = URL.createObjectURL(img.blob);

                    let peso = Math.round(img.peso / 1024)

                    htmlPreview += `
                <tr>
                    <td>
                            
                        <div style="width: 3.5em; height: 3.5em; display: flex; align-items: center; justify-content: center; flex-direction: row; overflow: hidden; border-radius: 0.5em;">
                            ${img.area === "C" ? `<img src="${objectURL}" style="width: -webkit-fill-available; height:-webkit-fill-available;">` : ``}
                            ${img.area === "RH" ? `<img src="${objectURL}" style="height:-webkit-fill-available;">` : ``}
                            ${img.area === "RV" ? ` <img src="${objectURL}" style="width: -webkit-fill-available;">` : ``}
                        </div>

                        <div style="display:flex; flex-direction: column; align-items: center; justify-content: center; height: 3em;">
                            
                            <p style="font-size: smaller; font-weight: bold; margin: 0em; padding: 0.5em" title="${img.name}">${img.name.length > 13 ? img.name.substring(0, 13) + '...' : img.name}</p>

                            <p style="font-size: smaller; margin: 0em; padding: 0.5em">${peso} KB</p>
                        </div>

                        <div class="actions">

                            ${index !== 0 ? `<svg class="svg" onclick="moveUp(${index})" class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v13m0-13 4 4m-4-4-4 4"/></svg>` : ``}
                            ${index === 0 ? `<svg class="svg2" style="color: white;" class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v13m0-13 4 4m-4-4-4 4"/></svg>` : ``}
                                
                            ${index !== allFiles.length - 1 ? `<svg class="svg" onclick="moveDown(${index})"  class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19V5m0 14-4-4m4 4 4-4"/></svg>` : ``}
                            ${index === allFiles.length - 1 ? `<svg class="svg2" style="color: white;" class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19V5m0 14-4-4m4 4 4-4"/></svg>` : ``}

                            <svg class="svg" onclick="editImg(${index})" class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24">
                            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.779 17.779 4.36 19.918 6.5 13.5m4.279 4.279 8.364-8.643a3.027 3.027 0 0 0-2.14-5.165 3.03 3.03 0 0 0-2.14.886L6.5 13.5m4.279 4.279L6.499 13.5m2.14 2.14 6.213-6.504M12.75 7.04 17 11.28"/>
                            </svg>

                            <svg  class="svg" onclick="deleteLine(${index})" class="w-6 h-6 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24">
                                <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18 17.94 6M18 18 6.06 6"/>
                            </svg>


                        </div>

                    </td>

                </tr>
                    `
                })

                // Acá le meteriamos el html a la tabla.
                table.innerHTML = htmlPreview;
                divTabla.style = "display: block";
            } else {
                divTabla.style = "display: none";
            }
        }

        function moveUp(index) {
            if (index > 0) {
                const temp = allFiles[index];
                allFiles[index] = allFiles[index - 1];
                allFiles[index - 1] = temp;
                mostrarImagenesEnTabla();
            }
        }

        function moveDown(index) {
            if (index < allFiles.length - 1) {
                const temp = allFiles[index];
                allFiles[index] = allFiles[index + 1];
                allFiles[index + 1] = temp;
                mostrarImagenesEnTabla();
            }
        }

        // CAPTURAMOS EL AREA DEL CROP:
        const divCrop = document.getElementById("divCrop")

        let imgDivCrop = ""

        // FUNCIÓN PARA RECORTAR IMAGEN:
        function editImg(index) {

            // Acá buscariamos en allFiles el archivo seleccionado para editar.
            let archivo = allFiles[index];
            // Acá tomariamos el blob y lo transformariamos en una "imagen" manipulable.
            const imgBlobURL = URL.createObjectURL(archivo.blob);

            divCrop.style = "display: flex; justify-content: center; align-items: center; flex-direction: column; margin-bottom: 1em; padding: 0.5em; padding-bottom: 0em; border: 1.5px dashed #ccc; border-radius: 0.7em; witdh:100%;";

            imgDivCrop = ""

            imgDivCrop += `
            
           <div style="width: 100%;">

                <img id="imgCargada" src="${imgBlobURL}" style="width: 100%; border-radius: 0.7em;">
           </div>

                <div style="width: 100%; display:flex; justify-content: space-between; align-items: center; flex-direction: row; margin: 1.5em 0em; ">

                    <button id="recortarBtn">Recortar</button>

                    <div style="display: flex; align-items: center; justify-content: space-evenly; width: 100%;">

                    <div id="cropC" class="shapes" style=" width: 1em; height: 1em;" ></div>
                    <div id="cropRV" class="shapes" style=" width: 1em; height: 2em;" ></div>
                    <div id="cropRH" class="shapes" style=" width: 2em; height: 1em;" ></div>

                    </div>

                    <button id="cerrarCropBtn">Cerrar editor</button>

                </div>
            `

            divCrop.innerHTML = imgDivCrop

            // Función para cambiar la relación de aspecto del área de recorte
            let areaRatio = 1;

            imgCargada.onload = function () {
                cropper = new Cropper(imgCargada, {
                    aspectRatio: areaRatio, // Cuadrado
                    viewMode: 1,  // Tamaño real
                    zoomable: false
                });
            };

            let cropC = document.getElementById("cropC");
            cropC.addEventListener('click', () => {
                areaRatio = 1;
                cropper.setAspectRatio(areaRatio);
            });

            let cropRV = document.getElementById("cropRV");
            cropRV.addEventListener('click', () => {
                areaRatio = 9 / 16;
                cropper.setAspectRatio(areaRatio);
            });

            let cropRH = document.getElementById("cropRH");
            cropRH.addEventListener('click', () => {
                areaRatio = 16 / 9;
                cropper.setAspectRatio(areaRatio);
            });



            let recortarBtn

            // LUEGO DE RECORTAR LA IMAGEN HAY QUE GUIARSE POR EL NAME DEL ARCHIVO PARA GUARDAR EL RECORTE, ESTO POR SI EL USUARIO CAMBIA DE LUGAR LOS ARCHIVOS, SI FUESE POR EL INDEX PODRIA GUARDARSE EL RECORTE EN EL ARCHIVO INCORRECTO. 

            let cerrarEdit = document.getElementById("cerrarCropBtn")
            cerrarEdit.addEventListener('click', () => {
                divCrop.innerHTML = ""
                divCrop.style = "display: none;"
            })

        }







        function deleteLine(index) {
            allFiles.splice(index, 1);
            actualizarParrafo(allFiles)
            mostrarImagenesEnTabla();
        }

        // Función para verificar si la extensión del archivo es permitida
        function esExtensionPermitida(archivo) {
            const extensionesPermitidas = ["jpg", "jpeg", "png"];
            const nombreArchivo = archivo.name.toLowerCase();
            const extension = nombreArchivo.substring(nombreArchivo.lastIndexOf(".") + 1);
            return extensionesPermitidas.includes(extension);
        }

        // Función para comprimir una imagen
        async function comprimirImagen(imagenComoArchivo) {

            // Esto crea una nueva promesa. Una promesa es un objeto que representa la eventual finalización o falla de una operación asíncrona.
            return new Promise((resolve, reject) => {

                // Aquí se crea un nuevo elemento <canvas> en el documento HTML. Este lienzo se usará para dibujar la imagen y luego comprimirla.
                const canvas = document.createElement("canvas");
                // Se crea un nuevo objeto de imagen. Esta imagen se usará para cargar y mostrar la imagen seleccionada por el usuario.
                const imagen = new Image();

                imagen.onload = () => {

                    let area = ""
                    if (imagen.width === imagen.height) {
                        area = "C"
                    } else if (imagen.width > imagen.height) {
                        area = "RH"
                    } else {
                        area = "RV"
                    }

                    // Aquí se establecen las dimensiones del lienzo (canvas) para que coincidan con las dimensiones de la imagen cargada.
                    canvas.width = imagen.width;
                    canvas.height = imagen.height;

                    // Esto dibuja la imagen cargada en el lienzo utilizando el contexto de dibujo 2D del lienzo. La imagen se dibuja en las coordenadas (0, 0) del lienzo.
                    canvas.getContext("2d").drawImage(imagen, 0, 0);

                    // Se llama al método toBlob del lienzo para convertir el contenido del lienzo en un objeto Blob. El objeto Blob resultante se pasa a la función de devolución de llamada proporcionada como primer argumento de toBlob. Si el blob es válido, la promesa se resuelve con el blob; de lo contrario, se rechaza con el blob.
                    canvas.toBlob(
                        (blob) => {
                            if (blob === null) {
                                return reject({ error: "No se pudo crear el blob", area });
                            } else {
                                resolve({ blob, area });
                            }
                        },
                        "image/jpeg",
                        40 / 100
                    );

                };

                imagen.src = URL.createObjectURL(imagenComoArchivo);

            });

        }

        const MAX_PESO_PERMITIDO = 20 * 1024 * 1024; // 40 megabytes en bytes

        // Esta es la función que se va a ejecutar cada vez que se selecione o suba un archivo.
        async function handleFiles(files) {
            // LA PRIMERA VALIDACIÓN ES PARA CUANDO SE VAN SE SELECCIONANDO DE A UNO HASTA LLEGAR A 5 LA SEGUNDA ES POR SI EL USUARIO SELECCIONA EN UNA SOLA VEZ MAS DE 5 IMAGENES.
            if (allFiles.length >= 5) {   // ACÁ VOY A TENER QUE AGREGAR LOS SWEET ALERT PARA EVITAR QUE SE PUEDA CARGAR MAS DE 5 IMAGENES POR PUBLICACIÓN. 
                alert("Ya subiste 5 archivos. Solo se pueden seleccionar hasta 5 imagenes por publicación.")
            }
            else {

                // Itera sobre cada archivo seleccionado
                for (let i = 0; i < files.length; i++) {

                    if (allFiles.length >= 5) {
                        // ACÁ VOY A TENER QUE AGREGAR LOS SWEET ALERT PARA EVITAR QUE SE PUEDA CARGAR MAS DE 5 IMAGENES POR PUBLICACIÓN. 
                        alert("Ya subiste 5 archivos. Solo se pueden seleccionar hasta 5 imagenes por publicación.")
                    } else {

                        const archivo = files[i];
                        // Acá habria que añadir la validación para el peso maximo y para la extención si es png o jpg, que no se admita archivos con otros tipos de extención. 
                        // Validaciones adicionales (por ejemplo, peso máximo y extensión)
                        if (archivo.size > MAX_PESO_PERMITIDO) {
                            alert("El archivo " + archivo.name + " supera el tamaño máximo permitido.");
                            continue; // Saltar al siguiente archivo si el peso es demasiado grande
                        }
                        if (!esExtensionPermitida(archivo)) {
                            alert("El archivo " + archivo.name + " tiene una extensión no permitida.");
                            continue; // Saltar al siguiente archivo si la extensión no es permitida
                        }

                        // Antes de guardar el archivo en el arreglo de allFiles ya deberiamos, extraer el nombre del archivo, extraer su peso en bytes y crear el blob, estas tres cosas son las que se deben guardar con cada imagen en allFiles, tiene que quedar algo asi  allFiles = [blob: dasd, name: sdasd, peso: 2312] 

                        // Comprimir la imagen y agregarla al arreglo allFiles
                        let imagenComprimida = await comprimirImagen(archivo)
                        const objetoArchivo = {
                            blob: imagenComprimida.blob,
                            area: imagenComprimida.area,
                            name: archivo.name,
                            peso: archivo.size
                        };
                        allFiles.push(objetoArchivo); // Agregar el archivo comprimido al arreglo allFiles

                    }
                }

            }

            actualizarParrafo(allFiles)

            // Acá llamariamos a la función que va a mostrar las imagenes en la tabla de preview.
            mostrarImagenesEnTabla()
        }





        /*
            
            Acá vamos a definir la logica para lo que se debe hacer luego de selecionar y ordenar todos los archivos.
            
                    // Este por ahora no nos interesa
                    const uploadButton = document.getElementById('uploadButton');
            
                    uploadButton.addEventListener('click', () => {
                        // Aquí puedes agregar la lógica para manejar la carga del archivo
                        alert('¡Archivo subido!');
                    });
            
            */

        uploadButton.addEventListener('click', () => {
            // Aquí puedes agregar la lógica para manejar la carga del archivo
            console.log(allFiles)


        });




    </script>
</body>

</html>